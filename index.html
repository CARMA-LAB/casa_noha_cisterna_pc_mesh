<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="description" content="CASA NOHA – Cisterna">
  <meta name="author" content="ARCANGELO PRIORE">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Potree Viewer – CASA NOHA (OBJ)</title>

  <link rel="stylesheet" type="text/css" href="./build/potree/potree.css">
  <link rel="stylesheet" type="text/css" href="./libs/jquery-ui/jquery-ui.min.css">
  <link rel="stylesheet" type="text/css" href="./libs/openlayers3/ol.css">
  <link rel="stylesheet" type="text/css" href="./libs/spectrum/spectrum.css">
  <link rel="stylesheet" type="text/css" href="./libs/jstree/themes/mixed/style.css">
</head>

<body>
  <!-- LIBS -->
  <script src="./libs/jquery/jquery-3.1.1.min.js"></script>
  <script src="./libs/spectrum/spectrum.js"></script>
  <script src="./libs/jquery-ui/jquery-ui.min.js"></script>
  <script src="./libs/other/BinaryHeap.js"></script>
  <script src="./libs/tween/tween.min.js"></script>
  <script src="./libs/d3/d3.js"></script>
  <script src="./libs/proj4/proj4.js"></script>
  <script src="./libs/openlayers3/ol.js"></script>
  <script src="./libs/i18next/i18next.js"></script>
  <script src="./libs/jstree/jstree.js"></script>
  <script src="./build/potree/potree.js"></script>
  <script src="./libs/plasio/js/laslaz.js"></script>

  <!-- CONTAINER -->
  <div class="potree_container" style="position:absolute; width:100%; height:100%; left:0; top:0;">
    <div id="potree_render_area"
         style="background-image:url('./build/potree/resources/images/NUOVO_LOGO_FAI.jpg');">
    </div>
    <div id="potree_sidebar_container"></div>
  </div>

  <!-- ✅ MODULE SCRIPT -->
  <script type="module">
    import * as THREE from "./libs/three.js/build/three.module.js";

    // Path A (come il tuo esempio). Se dà errore di import, commenta questa e usa la Path B.
    import { OBJLoader } from "./libs/three.js/loaders/OBJLoader.js";
    // Path B (alternativa comune):
    // import { OBJLoader } from "./libs/three.js/examples/jsm/loaders/OBJLoader.js";

    // -----------------------------
    // CONFIG
    // -----------------------------
    const POINTCLOUD_PATH = "./pointclouds/metadata.json";
    const OBJ_PATH = "./mesh/cisterna.obj";

    // Mesh: OFF di default
    const MESH_DEFAULT_VISIBLE = false;

    // ✅ Trasformazioni: lasciate “neutre” per NON rompere l’allineamento originale
    const MESH_SCALE  = 1.0;
    const MESH_ROT    = new THREE.Euler(0, 0, 0);
    const MESH_OFFSET = new THREE.Vector3(0, 0, 0);

    // -----------------------------
    // VIEWER
    // -----------------------------
    window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));

    viewer.setEDLEnabled(true);
    viewer.setFOV(60);
    viewer.setPointBudget(2_000_000);
    viewer.loadSettingsFromURL();

    viewer.setDescription("CASA NOHA – Cisterna (Point Cloud + OBJ mesh)");

    viewer.loadGUI(() => {
      viewer.setLanguage("en");
      $("#menu_scene").next().show();       // per vedere jstree_scene (toggle oggetti)
      $("#menu_appearance").next().show();
      // viewer.toggleSidebar();
    });

    // -----------------------------
    // LIGHTS
    // -----------------------------
    {
      const directional = new THREE.DirectionalLight(0xffffff, 1.0);
      directional.position.set(10, 10, 10);
      directional.lookAt(0, 0, 0);

      const ambient = new THREE.AmbientLight(0x777777);

      viewer.scene.scene.add(directional);
      viewer.scene.scene.add(ambient);
    }

    // =====================
    // POINT SIZE UI (come nel tuo esempio)
    // =====================
    function addPointSizeSliderToAppearance(material){

      const $appearancePanel = $("#menu_appearance").next();
      if ($appearancePanel.length === 0) {
        setTimeout(() => addPointSizeSliderToAppearance(material), 200);
        return;
      }

      // rimuove blocchi precedenti (se ricarichi)
      $("#ap_pointsize_block").remove();

      const typeToValue = t =>
        t === Potree.PointSizeType.ATTENUATED ? "ATTENUATED" :
        t === Potree.PointSizeType.ADAPTIVE   ? "ADAPTIVE"   : "FIXED";

      const valueToType = v =>
        v === "ATTENUATED" ? Potree.PointSizeType.ATTENUATED :
        v === "ADAPTIVE"   ? Potree.PointSizeType.ADAPTIVE   :
                             Potree.PointSizeType.FIXED;

      const block = $(`
        <div class="pv-menu-list" id="ap_pointsize_block">
          <div class="pv-menu-entry">

            <div style="display:flex; justify-content:space-between; margin-bottom:6px;">
              <span>Point size</span>
              <span id="ap_pointsize_val">${material.size.toFixed(1)}</span>
            </div>

            <div id="ap_pointsize_slider" style="margin:0 4px;"></div>

            <div id="ap_pointsize_note"
                 style="margin-top:6px; font-size:11px; color:#999; display:none;">
              controlled by distance
            </div>

            <div style="display:flex; justify-content:space-between; margin-top:8px;">
              <span>Size mode</span>
              <select id="ap_pointsize_type" style="width:140px;">
                <option value="FIXED">Fixed</option>
                <option value="ATTENUATED">Attenuated</option>
                <option value="ADAPTIVE">Adaptive</option>
              </select>
            </div>

          </div>
        </div>
      `);

      // inserisci dopo il primo blocco (come nel tuo)
      const $firstBlock = $appearancePanel.find(".pv-menu-list").first();
      $firstBlock.after(block);

      $("#ap_pointsize_type").val(typeToValue(material.pointSizeType));

      $("#ap_pointsize_slider").slider({
        min: 0.5,
        max: 10,
        step: 0.1,
        value: material.size,
        slide: (e, ui) => {
          material.size = ui.value;
          $("#ap_pointsize_val").text(ui.value.toFixed(1));
        }
      });

      function applyMode(mode){
        const $slider = $("#ap_pointsize_slider");
        const $note = $("#ap_pointsize_note");

        if (mode === "ATTENUATED") {
          $slider.slider("disable");
          $note.show();
          return;
        }

        $slider.slider("enable");
        $note.hide();

        if (mode === "ADAPTIVE") {
          $slider.slider("option", "max", 3);
          if ($slider.slider("value") > 3) {
            $slider.slider("value", 3);
            material.size = 3;
            $("#ap_pointsize_val").text("3.0");
          }
        } else {
          $slider.slider("option", "max", 10);
        }
      }

      applyMode(typeToValue(material.pointSizeType));

      $("#ap_pointsize_type").on("change", function(){
        const mode = $(this).val();
        material.pointSizeType = valueToType(mode);
        applyMode(mode);
      });
    }

    // -----------------------------
    // POINT CLOUD
    // -----------------------------
    Potree.loadPointCloud(POINTCLOUD_PATH, "Cisterna – Point Cloud", (e) => {
      const pc = e.pointcloud;

      viewer.scene.addPointCloud(pc);

      // Settaggi visuali iniziali
      pc.material.activeAttributeName = "rgba";
      pc.material.pointSizeType = Potree.PointSizeType.FIXED;
      pc.material.size = 2.0;
      pc.material.minSize = 2;

      // ✅ aggancia lo slider (stile Rocca)
      addPointSizeSliderToAppearance(pc.material);

      viewer.fitToScreen();

      // Mesh dopo la point cloud
      loadOBJ();
    });

    // -----------------------------
    // OBJ MESH + Sidebar toggle (jstree_scene)
    // -----------------------------
    let objMesh = null;

    function applyTransform(obj) {
      obj.scale.setScalar(MESH_SCALE);
      obj.rotation.copy(MESH_ROT);
      obj.position.add(MESH_OFFSET);
    }

    // NON sostituiamo il materiale (così non “perdi” texture/materiali se esistono),
    // al massimo forziamo DoubleSide per sicurezza.
    function keepMaterialsButDoubleSide(obj) {
      obj.traverse((child) => {
        if (child.isMesh && child.material) {
          const mats = Array.isArray(child.material) ? child.material : [child.material];
          for (const m of mats) {
            m.side = THREE.DoubleSide;
            m.needsUpdate = true;
          }
        }
      });
    }

    function registerInSceneTree(label, object3D) {
      viewer.onGUILoaded(() => {
        const tree = $(`#jstree_scene`);
        const parentNode = "other";

        const id = tree.jstree('create_node', parentNode, {
          text: label,
          icon: `${Potree.resourcePath}/icons/triangle.svg`,
          data: object3D
        }, "last", false, false);

        tree.jstree(object3D.visible ? "check_node" : "uncheck_node", id);
      });
    }

    function loadOBJ() {
      const loader = new OBJLoader();

      loader.load(
        OBJ_PATH,
        (object) => {
          objMesh = object;

          // OFF di default
          objMesh.visible = MESH_DEFAULT_VISIBLE;

          // NON sovrascriviamo i materiali (evita perdita texture)
          keepMaterialsButDoubleSide(objMesh);

          // trasformazioni neutre (non alterano se lasciate così)
          applyTransform(objMesh);

          viewer.scene.scene.add(objMesh);
          registerInSceneTree("Cisterna – Mesh OBJ", objMesh);

          console.log("OBJ loaded:", objMesh);
        },
        (xhr) => {
          if (xhr.lengthComputable) {
            const pct = (xhr.loaded / xhr.total) * 100;
            console.log(`OBJ: ${pct.toFixed(1)}%`);
          }
        },
        (err) => console.error("Errore caricamento OBJ:", err)
      );
    }
  </script>
</body>
</html>
